; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Local\SharpDevelop_3.2.0.5777_Source\src\AddIns\Misc\Profiler\Hook\CircularBuffer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
PUBLIC	?NextOffset@CCircularBuffer@@AAEHH@Z		; CCircularBuffer::NextOffset
; Function compile flags: /Ogtpy
; File c:\local\sharpdevelop_3.2.0.5777_source\src\addins\misc\profiler\hook\circularbuffer.cpp
;	COMDAT ?NextOffset@CCircularBuffer@@AAEHH@Z
_TEXT	SEGMENT
?NextOffset@CCircularBuffer@@AAEHH@Z PROC		; CCircularBuffer::NextOffset, COMDAT
; _this$ = edx
; _offset$ = ecx

; 162  : 	offset += 1;

	inc	ecx

; 163  : 	if (offset == this->dataLength)

	mov	eax, ecx
	sub	eax, DWORD PTR [edx+8]
	neg	eax
	sbb	eax, eax
	and	eax, ecx

; 164  : 		return 0;
; 165  : 	else
; 166  : 		return offset;
; 167  : }

	ret	0
?NextOffset@CCircularBuffer@@AAEHH@Z ENDP		; CCircularBuffer::NextOffset
PUBLIC	?WriteInternal@CCircularBuffer@@AAEHPAEHH@Z	; CCircularBuffer::WriteInternal
; Function compile flags: /Ogtpy
;	COMDAT ?WriteInternal@CCircularBuffer@@AAEHPAEHH@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
_offset$ = 12						; size = 4
_count$ = 16						; size = 4
?WriteInternal@CCircularBuffer@@AAEHPAEHH@Z PROC	; CCircularBuffer::WriteInternal, COMDAT
; _this$ = esi

; 128  : 	// read startOffset and endOffset from shared memory
; 129  : 	int startOffset = this->header->StartOffset;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+8]

; 130  : 	int endOffset = this->header->EndOffset;

	mov	edx, DWORD PTR [esi]
	push	ebx

; 131  : 	// wait until there's room
; 132  : 	while (NextOffset(endOffset) == startOffset) {

	mov	ebx, DWORD PTR __imp__WaitForSingleObject@8
	push	ebp
	push	edi
	mov	edi, DWORD PTR [edx+12]
	lea	ebp, DWORD PTR [edi+1]
$LL8@WriteInter:
	mov	eax, ebp
	sub	eax, DWORD PTR [esi+8]
	neg	eax
	sbb	eax, eax
	and	eax, ebp
	cmp	eax, ecx
	jne	SHORT $LN7@WriteInter

; 133  : 		if (this->nonFullEvent->Wait() == WAIT_TIMEOUT)

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+4]
	push	-1
	push	eax
	call	ebx
	cmp	eax, 258				; 00000102H
	je	SHORT $LN24@WriteInter

; 135  : 		// the reader should have changed the start offset
; 136  : 		startOffset = this->header->StartOffset;

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+8]

; 137  : 	}

	jmp	SHORT $LL8@WriteInter
$LN24@WriteInter:
	pop	edi
	pop	ebp

; 134  : 			return -1;

	or	eax, -1
	pop	ebx

; 158  : }

	ret	12					; 0000000cH
$LN7@WriteInter:

; 138  : 	int writeEndOffset;
; 139  : 	if (startOffset <= endOffset) {

	cmp	ecx, edi
	jg	SHORT $LN5@WriteInter

; 140  : 		// free space wraps over buffer end
; 141  : 		if (startOffset == 0)
; 142  : 			writeEndOffset = this->dataLength - 1; // one byte must always be left free

	mov	eax, DWORD PTR [esi+8]
	test	ecx, ecx
	jne	SHORT $LN2@WriteInter
	dec	eax

; 143  : 		else

	jmp	SHORT $LN2@WriteInter
$LN5@WriteInter:

; 144  : 			writeEndOffset = this->dataLength;
; 145  : 	} else {
; 146  : 		writeEndOffset = startOffset - 1; // one byte must be left free to distinguish between empty and full buffer

	lea	eax, DWORD PTR [ecx-1]
$LN2@WriteInter:

; 147  : 	}
; 148  : 	int writeCount = min(count, writeEndOffset - endOffset);

	mov	ebx, DWORD PTR _count$[esp+8]
	sub	eax, edi
	cmp	ebx, eax
	jl	SHORT $LN12@WriteInter
	mov	ebx, eax
$LN12@WriteInter:

; 149  : 	
; 150  : 	memcpy(this->data + endOffset, data + offset, writeCount);

	mov	edx, DWORD PTR _offset$[esp+8]
	mov	eax, DWORD PTR _data$[esp+8]
	mov	ecx, DWORD PTR [esi+4]
	push	ebx
	add	eax, edx
	push	eax
	add	ecx, edi
	push	ecx
	call	_memcpy

; 151  : 	endOffset += writeCount; // advance endOffset

	add	edi, ebx
	add	esp, 12					; 0000000cH

; 152  : 	if (endOffset == this->dataLength) // wrap around startOffset if required

	cmp	edi, DWORD PTR [esi+8]
	jne	SHORT $LN1@WriteInter

; 153  : 		endOffset = 0;

	xor	edi, edi
$LN1@WriteInter:

; 154  : 
; 155  : 	this->header->EndOffset = endOffset; // write back endOffset to shared memory

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [edx+12], edi

; 156  : 	this->nonEmptyEvent->Set(); // we wrote something, so the buffer is not empty anymore

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__SetEvent@4
	pop	edi
	pop	ebp

; 157  : 	return writeCount;

	mov	eax, ebx
	pop	ebx

; 158  : }

	ret	12					; 0000000cH
?WriteInternal@CCircularBuffer@@AAEHPAEHH@Z ENDP	; CCircularBuffer::WriteInternal
_TEXT	ENDS
PUBLIC	?Write@CCircularBuffer@@QAEHPAEHH@Z		; CCircularBuffer::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CCircularBuffer@@QAEHPAEHH@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?Write@CCircularBuffer@@QAEHPAEHH@Z PROC		; CCircularBuffer::Write, COMDAT
; _this$ = ecx
; _count$ = eax

; 88   : {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _data$[esp+4]
	push	esi
	xor	ebx, ebx
	push	edi
	mov	edi, eax
	mov	esi, ecx

; 89   : 	if (data == nullptr)

	test	ebp, ebp
	jne	SHORT $LN5@Write
	pop	edi
	pop	esi
	pop	ebp

; 90   : 		return -1;

	or	eax, -1
	pop	ebx

; 102  : }

	ret	4
$LN5@Write:

; 91   : 	if (count < 0)

	test	edi, edi
	jge	SHORT $LN10@Write
	pop	edi
	pop	esi
	pop	ebp

; 92   : 		return -2;

	mov	eax, -2					; fffffffeH
	pop	ebx

; 102  : }

	ret	4
$LN10@Write:

; 93   : 	if (offset < 0)
; 94   : 		return -3;
; 95   : 	
; 96   : 	while (count > 0) {

	jle	SHORT $LN1@Write
	npad	2
$LL2@Write:

; 97   : 		int r = WriteInternal(data, offset, count);

	push	edi
	push	ebx
	push	ebp
	call	?WriteInternal@CCircularBuffer@@AAEHPAEHH@Z ; CCircularBuffer::WriteInternal

; 98   : 		offset += r;
; 99   : 		count -= r;

	sub	edi, eax
	add	ebx, eax
	test	edi, edi
	jg	SHORT $LL2@Write
$LN1@Write:

; 100  : 	}
; 101  : 	return count;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 102  : }

	ret	4
?Write@CCircularBuffer@@QAEHPAEHH@Z ENDP		; CCircularBuffer::Write
_TEXT	ENDS
PUBLIC	??0CCircularBuffer@@QAE@PAX@Z			; CCircularBuffer::CCircularBuffer
; Function compile flags: /Ogtpy
;	COMDAT ??0CCircularBuffer@@QAE@PAX@Z
_TEXT	SEGMENT
??0CCircularBuffer@@QAE@PAX@Z PROC			; CCircularBuffer::CCircularBuffer, COMDAT
; _this$ = esi
; _start$ = eax

; 13   : {

	push	ebx

; 14   : 	this->header = (CircularBufferHeader*)start;
; 15   : 	if (this->header->Magic != '~CB1') {
; 16   : 		DebugWriteLine(L"Corrupted buffer header");
; 17   : 	}
; 18   : 	this->data = (byte*)(this->header + 1);

	lea	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ecx

; 19   : 	this->dataLength = this->header->TotalLength - sizeof(CircularBufferHeader);

	mov	edx, DWORD PTR [eax+4]
	push	ebp
	push	edi
	sub	edx, 24					; 00000018H
	mov	DWORD PTR [esi+8], edx

; 20   : 	this->nonFullEvent = OpenEventWaitHandle(GetEventName(this->header->NonFullEventName));

	mov	edi, DWORD PTR [eax+20]
	push	128					; 00000080H
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ebp, DWORD PTR __imp__sprintf_s
	push	edi
	push	OFFSET ??_C@_0BI@BBOPOAJD@Local?2Profiler?4Event?4?$CFd?$AA@
	mov	ebx, eax
	push	128					; 00000080H
	push	ebx
	call	ebp
	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 24					; 00000018H
	test	edi, edi
	je	SHORT $LN11@CCircularB
	push	ebx
	push	0
	push	1048578					; 00100002H
	mov	DWORD PTR [edi], ebx
	call	DWORD PTR __imp__OpenEventA@12
	mov	DWORD PTR [edi+4], eax
	mov	eax, edi
	jmp	SHORT $LN12@CCircularB
$LN11@CCircularB:
	xor	eax, eax
$LN12@CCircularB:
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN8@CCircularB
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
$LN8@CCircularB:
	mov	DWORD PTR [esi+16], eax

; 21   : 	this->nonEmptyEvent = OpenEventWaitHandle(GetEventName(this->header->NonEmptyEventName));

	mov	eax, DWORD PTR [esi]
	mov	edi, DWORD PTR [eax+16]
	push	128					; 00000080H
	call	??_U@YAPAXI@Z				; operator new[]
	push	edi
	push	OFFSET ??_C@_0BI@BBOPOAJD@Local?2Profiler?4Event?4?$CFd?$AA@
	mov	ebx, eax
	push	128					; 00000080H
	push	ebx
	call	ebp
	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 24					; 00000018H
	test	edi, edi
	je	SHORT $LN23@CCircularB
	push	ebx
	push	0
	push	1048578					; 00100002H
	mov	DWORD PTR [edi], ebx
	call	DWORD PTR __imp__OpenEventA@12
	mov	DWORD PTR [edi+4], eax
	jmp	SHORT $LN24@CCircularB
$LN23@CCircularB:
	xor	edi, edi
$LN24@CCircularB:
	cmp	DWORD PTR [edi+4], 0
	jne	SHORT $LN20@CCircularB
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
	xor	eax, eax
	pop	ebp
	mov	DWORD PTR [esi+12], eax

; 22   : 
; 23   : 	if (this->nonFullEvent != nullptr)
; 24   : 		DebugWriteLine(L"nonFullEvent found!\n");
; 25   : 	if (this->nonEmptyEvent != nullptr)
; 26   : 		DebugWriteLine(L"nonEmptyEvent found!\n");
; 27   : 
; 28   : 	DebugWriteLine(L"circular buffer header: %x %x %x %x\n", this->header->StartOffset, this->header->EndOffset, this->header->NonEmptyEventName, this->header->NonFullEventName);
; 29   : }

	mov	eax, esi
	pop	ebx
	ret	0

; 21   : 	this->nonEmptyEvent = OpenEventWaitHandle(GetEventName(this->header->NonEmptyEventName));

$LN20@CCircularB:
	mov	DWORD PTR [esi+12], edi
	pop	edi
	pop	ebp

; 22   : 
; 23   : 	if (this->nonFullEvent != nullptr)
; 24   : 		DebugWriteLine(L"nonFullEvent found!\n");
; 25   : 	if (this->nonEmptyEvent != nullptr)
; 26   : 		DebugWriteLine(L"nonEmptyEvent found!\n");
; 27   : 
; 28   : 	DebugWriteLine(L"circular buffer header: %x %x %x %x\n", this->header->StartOffset, this->header->EndOffset, this->header->NonEmptyEventName, this->header->NonFullEventName);
; 29   : }

	mov	eax, esi
	pop	ebx
	ret	0
??0CCircularBuffer@@QAE@PAX@Z ENDP			; CCircularBuffer::CCircularBuffer
PUBLIC	?WriteInt@CCircularBuffer@@QAEHH@Z		; CCircularBuffer::WriteInt
; Function compile flags: /Ogtpy
;	COMDAT ?WriteInt@CCircularBuffer@@QAEHH@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?WriteInt@CCircularBuffer@@QAEHH@Z PROC			; CCircularBuffer::WriteInt, COMDAT
; _this$ = eax

; 115  : {

	push	ebx
	push	esi
	push	edi
	mov	esi, eax

; 116  : 	return Write((byte*)&data, 0, 4);

	mov	edi, 4
	xor	ebx, ebx
	npad	4
$LL4@WriteInt:
	push	edi
	push	ebx
	lea	eax, DWORD PTR _data$[esp+16]
	push	eax
	call	?WriteInternal@CCircularBuffer@@AAEHPAEHH@Z ; CCircularBuffer::WriteInternal
	sub	edi, eax
	add	ebx, eax
	test	edi, edi
	jg	SHORT $LL4@WriteInt
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 117  : }

	ret	4
?WriteInt@CCircularBuffer@@QAEHH@Z ENDP			; CCircularBuffer::WriteInt
PUBLIC	?WriteString@CCircularBuffer@@QAEHPA_W@Z	; CCircularBuffer::WriteString
; Function compile flags: /Ogtpy
;	COMDAT ?WriteString@CCircularBuffer@@QAEHPA_W@Z
_TEXT	SEGMENT
$T178537 = -4						; size = 4
_string$ = 8						; size = 4
?WriteString@CCircularBuffer@@QAEHPA_W@Z PROC		; CCircularBuffer::WriteString, COMDAT
; _this$ = eax

; 120  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 121  : 	int len = (int)(wcslen(string) * sizeof(WCHAR));

	mov	eax, DWORD PTR _string$[esp+12]
	push	edi
	lea	edx, DWORD PTR [eax+2]
	npad	2
$LL17@WriteStrin:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL17@WriteStrin
	sub	eax, edx
	sar	eax, 1
	lea	ebp, DWORD PTR [eax+eax]

; 122  : 	WriteInt(len);

	mov	DWORD PTR $T178537[esp+20], ebp
	mov	edi, 4
	xor	ebx, ebx
	npad	3
$LL6@WriteStrin:
	push	edi
	push	ebx
	lea	eax, DWORD PTR $T178537[esp+28]
	push	eax
	call	?WriteInternal@CCircularBuffer@@AAEHPAEHH@Z ; CCircularBuffer::WriteInternal
	sub	edi, eax
	add	ebx, eax
	test	edi, edi
	jg	SHORT $LL6@WriteStrin

; 123  : 	return Write((byte *)string, 0, len);

	mov	ecx, DWORD PTR _string$[esp+16]
	push	ecx
	mov	eax, ebp
	mov	ecx, esi
	call	?Write@CCircularBuffer@@QAEHPAEHH@Z	; CCircularBuffer::Write
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 124  : }

	pop	ecx
	ret	4
?WriteString@CCircularBuffer@@QAEHPA_W@Z ENDP		; CCircularBuffer::WriteString
END
